package ui

import "github.com/preslavrachev/backoffice/core"
import "context"
import "fmt"
import "reflect"
import "strings"


templ List(resource *core.Resource, items []interface{}, totalCount int, loadMoreURL string) {
	<div class="bg-white shadow rounded-lg">
		<div class="px-6 py-4 border-b border-gray-200 flex justify-between items-center">
			<div>
				<h2 class="text-lg font-medium text-gray-900 capitalize" data-pw="resource-title">
					{ resource.PluralName } ({ fmt.Sprintf("%d", totalCount) } total)
				</h2>
			</div>
			<div class="flex space-x-2">
				<a href="/admin" class="bg-gray-600 text-white px-4 py-2 rounded hover:bg-gray-700" data-pw="back-to-admin-button">‚Üê Back to Admin</a>
				<button hx-get={ "/admin/api/" + resource.Name + "/new" }
				        hx-target="body"
				        hx-swap="beforeend"
				        class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 capitalize transition-colors"
				        data-pw="add-new-button">
					Add New { resource.DisplayName }
				</button>
			</div>
		</div>
		
		if len(items) == 0 {
			<div class="text-center py-8" data-pw="empty-state">
				<p class="text-gray-500 capitalize" data-pw="empty-message">No { resource.DisplayName } records found.</p>
				<button hx-get={ "/admin/api/" + resource.Name + "/new" }
				        hx-target="body"
				        hx-swap="beforeend"
				        class="mt-4 inline-block bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 capitalize transition-colors"
				        data-pw="create-first-button">
					Create First { resource.DisplayName }
				</button>
			</div>
		} else {
			<div class="overflow-x-auto">
				<table class="min-w-full divide-y divide-gray-200" data-pw="resource-table">
					<thead class="bg-gray-50">
						<tr data-pw="table-header-row">
							for _, field := range resource.Fields {
								@SortableHeaderWithSort(field, resource.Name, getCurrentSortField(ctx), getCurrentSortDirection(ctx))
							}
							<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider" data-pw="actions-header">
								Actions
							</th>
						</tr>
					</thead>
					<tbody class="bg-white divide-y divide-gray-200" id="table-body" data-pw="table-body">
						for _, item := range items {
							@ListRow(resource, item)
						}
						@LoadMoreButton(resource, totalCount, loadMoreURL)
					</tbody>
				</table>
			</div>
		}
	</div>
}

templ ListRow(resource *core.Resource, item interface{}) {
	<tr class="delete-row border-b border-gray-100 hover:bg-gray-50 transition-all duration-300 ease-in-out group"
		x-data="{ deleting: false }" data-pw="resource-row">
		for _, field := range resource.Fields {
			<td class="px-6 py-3 text-sm align-top">
				if field.Relationship != nil && field.Relationship.Type == core.RelationshipManyToOne {
					// Use appropriate relationship display pattern
					if field.Relationship.DisplayPattern == "badge" {
						@BadgeRelationshipDisplay(item, field, resource.Name)
					} else if field.Relationship.DisplayPattern == "hierarchical" {
						@HierarchicalRelationshipDisplay(item, field, resource.Name)
					} else {
						// Default to compact pattern
						@CompactRelationshipDisplay(item, field, resource.Name)
					}
				} else {
					// Check if this is a slice/array field that should be clickable
					@displayFieldValue(item, &field, resource)
				}
			</td>
		}
		<td class="px-6 py-4 whitespace-nowrap text-sm font-medium align-top" data-pw="actions-cell">
			<div class="flex space-x-2 items-center">
				<a href={ templ.URL("/admin/" + resource.Name + "/" + fmt.Sprintf("%v", core.GetFieldValue(item, resource.IDField))) }
				   class="text-blue-600 hover:text-blue-900 transition-colors" data-pw="view-button">View</a>
				<button hx-get={ "/admin/api/" + resource.Name + "/" + fmt.Sprintf("%v", core.GetFieldValue(item, resource.IDField)) + "/edit" }
				        hx-target="body"
				        hx-swap="beforeend"
				        class="text-yellow-600 hover:text-yellow-900 transition-colors" data-pw="edit-button">Edit</button>
				<button 
					x-show="!deleting"
					hx-delete={ "/admin/api/" + resource.Name + "/" + fmt.Sprintf("%v", core.GetFieldValue(item, resource.IDField)) }
					hx-target="closest tr"
					hx-swap="delete swap:0.5s"
					hx-on::before-request="$el.closest('tr').classList.add('opacity-50', 'pointer-events-none'); deleting = true"
					hx-on::after-request="deleting = false; if(event.detail.xhr.status !== 200) { $el.closest('tr').classList.remove('opacity-50', 'pointer-events-none') }"
					hx-confirm={ "Are you sure you want to delete this " + resource.DisplayName + "? This action cannot be undone." }
					class="text-red-600 hover:text-red-900 transition-colors disabled:opacity-50" data-pw="delete-button">
					Delete
				</button>
				<div x-show="deleting" x-transition class="text-gray-500 text-sm" data-pw="deleting-status">
					Deleting...
				</div>
			</div>
			</td>
	</tr>
}

// displayFieldValue handles different field types with appropriate display and interactions
templ displayFieldValue(item interface{}, field *core.FieldInfo, resource *core.Resource) {
	// Check if this field contains slice/array data that should be clickable
	if isSliceField(item, field.Name) {
		@sliceFieldDisplay(item, field, resource)
	} else {
		// Handle boolean fields with Yes/No badges (non-clickable)
		if field.Type == "bool" {
			@FormatBooleanField(core.GetFieldValue(item, field.Name))
		} else {
			// Regular field display with clickable link to detail view
			<a href={ templ.URL("/admin/" + resource.Name + "/" + fmt.Sprintf("%v", core.GetFieldValue(item, resource.IDField))) }
			   class="block text-gray-900 hover:text-blue-600 group relative">
				<div class="font-medium text-gray-900 pr-6">
					if field.RenderAs == core.RenderHTML || field.RenderAs == core.RenderRichText {
						<span class="inline-flex items-center px-1.5 py-0.5 rounded text-xs font-medium bg-purple-100 text-purple-800 mr-1.5">
							HTML
						</span>
					}
					<span>{ core.FormatFieldValueForDisplay(item, field) }</span>
				</div>
				if isFieldTruncated(item, field) {
					<span class="absolute top-0 right-0 text-gray-400 group-hover:text-blue-600 transition-colors">
						<svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>
						</svg>
					</span>
				}
			</a>
		}
	}
}

// sliceFieldDisplay shows clickable count for slice/array fields
templ sliceFieldDisplay(item interface{}, field *core.FieldInfo, resource *core.Resource) {
	<button hx-get={ "/admin/api/" + resource.Name + "/" + fmt.Sprintf("%v", core.GetFieldValue(item, resource.IDField)) + "/related/" + field.Name }
	        hx-target="body"
	        hx-swap="beforeend"
	        class="text-blue-600 hover:text-blue-800 hover:underline transition-colors cursor-pointer">
		{ getSliceDisplayText(item, field) }
	</button>
}

// Helper function to check if a field contains slice/array data
func isSliceField(item interface{}, fieldName string) bool {
	value := core.GetFieldValue(item, fieldName)
	if value == nil {
		return false
	}
	
	reflectVal := reflect.ValueOf(value)
	return reflectVal.Kind() == reflect.Slice || reflectVal.Kind() == reflect.Array
}

// Helper function to get display text for slice fields
func getSliceDisplayText(item interface{}, field *core.FieldInfo) string {
	value := core.GetFieldValue(item, field.Name)
	if value == nil {
		return "0"
	}
	
	reflectVal := reflect.ValueOf(value)
	if reflectVal.Kind() == reflect.Slice || reflectVal.Kind() == reflect.Array {
		count := reflectVal.Len()
		if count == 0 {
			return "0"
		}
		
		// Generate a user-friendly label based on field name
		fieldLabel := getFieldLabel(field.Name)
		if count == 1 {
			return fmt.Sprintf("1 %s", fieldLabel)
		}
		return fmt.Sprintf("%d %s", count, fieldLabel)
	}
	
	return fmt.Sprintf("%v", value)
}

// Helper function to convert field names to user-friendly labels
func getFieldLabel(fieldName string) string {
	switch fieldName {
	case "Children":
		return "child"
	case "Products":
		return "product"
	case "Users":
		return "user"
	case "Categories":
		return "category"
	default:
		// Convert CamelCase to lowercase
		if len(fieldName) > 0 {
			return strings.ToLower(fieldName[:len(fieldName)-1]) // Remove 's' for singular
		}
		return "item"
	}
}

// FormatBooleanField displays boolean values as Yes/No badges
templ FormatBooleanField(value interface{}) {
	if fmt.Sprintf("%v", value) == "true" {
		<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
			Yes
		</span>
	} else {
		<span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
			No
		</span>
	}
}

// SortableHeader renders a clickable column header with sort indicators (legacy, for compatibility)
templ SortableHeader(field core.FieldInfo, resourceName string) {
	@SortableHeaderWithSort(field, resourceName, "", "")
}

// SortableHeaderWithSort renders a clickable column header with current sort state indicators
templ SortableHeaderWithSort(field core.FieldInfo, resourceName, currentSortField, currentSortDirection string) {
	<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
		<button onclick={ templ.JSFuncCall("sortTable", field.Name) }
		        class="flex items-center space-x-1 hover:text-gray-700 focus:outline-none group transition-colors">
			<span class={ getSortHeaderTextClass(field.Name, currentSortField) }>{ field.DisplayName }</span>
			<div class="flex flex-col">
				if field.Name == currentSortField && currentSortDirection == "asc" {
					<!-- Active ascending arrow -->
					<svg class="w-3 h-3 text-blue-600 -mb-1" fill="currentColor" viewBox="0 0 20 20">
						<path d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z"/>
					</svg>
					<svg class="w-3 h-3 -mt-1 opacity-20" fill="currentColor" viewBox="0 0 20 20">
						<path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/>
					</svg>
				} else if field.Name == currentSortField && currentSortDirection == "desc" {
					<!-- Active descending arrow -->
					<svg class="w-3 h-3 -mb-1 opacity-20" fill="currentColor" viewBox="0 0 20 20">
						<path d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z"/>
					</svg>
					<svg class="w-3 h-3 text-blue-600 -mt-1" fill="currentColor" viewBox="0 0 20 20">
						<path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/>
					</svg>
				} else {
					<!-- Inactive/unsorted state -->
					<div class="opacity-30 group-hover:opacity-60 transition-opacity">
						<svg class="w-3 h-3 -mb-1" fill="currentColor" viewBox="0 0 20 20">
							<path d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z"/>
						</svg>
						<svg class="w-3 h-3 -mt-1" fill="currentColor" viewBox="0 0 20 20">
							<path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/>
						</svg>
					</div>
				}
			</div>
		</button>
	</th>
}

// LoadMoreButton renders a "Load More" button if there are more results
templ LoadMoreButton(resource *core.Resource, totalCount int, loadMoreURL string) {
	if totalCount > core.DefaultPageSize && loadMoreURL != "" {
		<tr id="load-more-row">
			<td colspan={ fmt.Sprintf("%d", len(resource.Fields)+1) } class="px-6 py-4 text-center">
				<button hx-get={ loadMoreURL }
				        hx-target="#load-more-row" 
				        hx-swap="outerHTML"
				        class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 transition-colors"
				        data-pw="load-more-button">
					Load More ({ fmt.Sprintf("%d", totalCount - core.DefaultPageSize) } more available)
				</button>
			</td>
		</tr>
	}
}


// Helper functions for sort state management

// getCurrentSortField extracts the current sort field from context
func getCurrentSortField(ctx context.Context) string {
	if sortField, ok := ctx.Value("currentSortField").(string); ok {
		return sortField
	}
	return ""
}

// getCurrentSortDirection extracts the current sort direction from context
func getCurrentSortDirection(ctx context.Context) string {
	if sortDirection, ok := ctx.Value("currentSortDirection").(string); ok {
		return sortDirection
	}
	return ""
}

// getSortHeaderTextClass returns CSS classes for header text based on sort state
func getSortHeaderTextClass(fieldName, currentSortField string) string {
	if fieldName == currentSortField {
		return "text-blue-600 font-medium"
	}
	return ""
}

// isFieldTruncated checks if a field value was truncated based on MaxPreviewLength
func isFieldTruncated(item interface{}, field *core.FieldInfo) bool {
	if field.MaxPreviewLength <= 0 {
		return false
	}

	rawValue := core.GetFieldValue(item, field.Name)
	if rawValue == nil {
		return false
	}

	// Get the raw string value
	rawStr := fmt.Sprintf("%v", rawValue)

	// For HTML fields, strip tags first to get actual text length
	if field.RenderAs == core.RenderHTML || field.RenderAs == core.RenderRichText {
		// We don't have direct access to stripHTMLTags here, but we can estimate
		// by checking if raw HTML is significantly longer than MaxPreviewLength
		return len(rawStr) > field.MaxPreviewLength
	}

	return len(rawStr) > field.MaxPreviewLength
}